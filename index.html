<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Food Diary</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Montserrat', Arial, sans-serif;
      margin: 20px;
      background: #F3EFFF;
      color: #2D2D2D;
      min-height: 100vh;
    }
    h1 {
      text-align: center;
      font-size: 32px;
      background: linear-gradient(90deg, #7B3FA1, #A678F0, #D6A2E8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 10px rgba(123, 63, 161, 0.3);
      font-weight: 700;
    }
    form {
      margin-bottom: 20px;
      background: #FFFFFF;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    label {
      display: block;
      margin-top: 10px;
    }
    input, textarea, button, select {
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      border: 1px solid #A678F0;
      border-radius: 5px;
      box-sizing: border-box;
      background: #FFFFFF;
      color: #2D2D2D;
    }
    input[type="date"], input[type="time"], input[type="text"], input[type="number"] {
      max-width: 300px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background: #FFFFFF;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    th, td {
      padding: 10px;
      border: 1px solid #A678F0;
      text-align: left;
      vertical-align: middle;
    }
    th {
      background: #7B3FA1;
      color: #FFFFFF;
    }
    .btn-export {
      margin-top: 20px;
      padding: 10px;
      background: #7B3FA1;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .btn-export:hover {
      background: #D6A2E8;
    }
    /* new button accents */
    .btn-add {
      background: linear-gradient(180deg, #7B3FA1, #6A2E91);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    .btn-add:hover { filter: brightness(0.95); }
    .btn-delete {
      background: linear-gradient(180deg, #F44336, #D32F2F);
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
    }
    .btn-delete:hover { filter: brightness(0.95); }
    .btn-edit {
      background: linear-gradient(180deg, #A678F0, #8E5BDD);
      color: #2D2D2D;
      border: none;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
    }
    .btn-edit:hover { filter: brightness(0.98); }

    /* Accessible focus outlines for all accent buttons */
    .btn-add:focus, .btn-delete:focus, .btn-edit:focus, .btn-export:focus {
      outline: 3px solid rgba(34,139,230,0.25);
      outline-offset: 2px;
    }

    /* Slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 10px;
      background: #e0e0e0;
      border-radius: 5px;
      outline: none;
      position: relative;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #7B3FA1, #6A2E91);
      border: 2px solid #fff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      background: linear-gradient(135deg, #6A2E91, #5A1F81);
    }
    input[type="range"]::-webkit-slider-thumb:focus {
      outline: 2px solid #A678F0;
      outline-offset: 2px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #7B3FA1, #6A2E91);
      border: 2px solid #fff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      border: none;
    }
    input[type="range"]::-moz-range-thumb:hover {
      background: linear-gradient(135deg, #6A2E91, #5A1F81);
    }
    input[type="range"]::-moz-range-thumb:focus {
      outline: 2px solid #4CAF50;
      outline-offset: 2px;
    }
    /* Add numbers at ends */
    input[type="range"]::before {
      content: "0";
      position: absolute;
      left: -12px;
      top: 12px;
      font-size: 12px;
      color: #666;
    }
    input[type="range"]::after {
      content: "10";
      position: absolute;
      right: -17px;
      top: 12px;
      font-size: 12px;
      color: #666;
    }

    /* stronger heading weight */
    h1 { font-weight: 700; }
    summary { font-weight: 600; }
    img.photo-thumb {
      max-width: 50px;
      max-height: 50px;
      display: block;
      cursor: pointer;
    }
    /* Modal / lightbox styles */
    .img-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
    }
    /* show when opened */
    .img-modal.open {
      display: flex;
    }
    .img-modal-content {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      overflow: hidden;
      background: transparent;
      border-radius: 8px;
    }
    .img-modal img {
      display: block;
      user-select: none;
      -webkit-user-drag: none;
      transform-origin: center center;
      cursor: grab;
      will-change: transform;
      /* ensure image fits inside modal content so scale/translate are visible */
      max-width: 100%;
      max-height: 100%;
    }
    .img-modal .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 8px;
    }
    .img-modal .controls button {
      padding: 6px 8px;
      background: rgba(255,255,255,0.9);
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    /* Mood layout tweaks */
    .mood-summary { cursor:pointer; font-weight: normal; margin-bottom: 8px; color: #7A7A7A; }
    summary { color: #7A7A7A; }
    .mood-cat { font-weight: normal; margin-bottom: 6px; color: #2D2D2D; }
  .mood-grid { display: flex; flex-direction: column; gap: 4px; }
  .mood-item { display: flex; align-items: center; gap: 12px; }
  .mood-checkbox { }
  .mood-label { }
  .mood-item input { margin:0; }
  </style>
</head>
<body>
  <h1>‚≠ê My Food Diary ‚≠ê</h1>
  <div id="editBanner" style="display:none;background:#FFFFFF;border:1px solid #A678F0;padding:10px;border-radius:6px;margin-bottom:12px;color:#2D2D2D;">
    <strong>Editing entry</strong>
    <span id="editBannerMsg" style="margin-left:8px;color:#7A7A7A;">You're editing an existing entry ‚Äî make changes and click Save or Cancel.</span>
    <button id="cancelEditBtn" style="float:right;background:#2D2A3D;border:1px solid #B39DDB;padding:6px 8px;border-radius:4px;cursor:pointer;color:#FFFFFF;">Cancel</button>
  </div>

  <form id="foodForm">
    <label>Date:
      <input type="date" id="date" required />
    </label>
    <label>Time:
      <input type="time" id="time" required />
    </label>
    <details style="margin-top:14px;" open>
      <summary class="mood-summary">Mood</summary>
      <fieldset style="border:1px solid #A678F0;padding:10px;border-radius:6px;text-align:left;">
      <div style="display:flex;gap:24px;flex-wrap:wrap;">
        <div>
          <div class="mood-cat">üåßÔ∏è Negative / distress</div>
          <div class="mood-grid">
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Anxious / worried"></div>
              <div class="mood-label">Anxious / worried</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Angry / frustrated"></div>
              <div class="mood-label">Angry / frustrated</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Sad / down"></div>
              <div class="mood-label">Sad / down</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Lonely"></div>
              <div class="mood-label">Lonely</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Guilty / ashamed"></div>
              <div class="mood-label">Guilty / ashamed</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Overwhelmed"></div>
              <div class="mood-label">Overwhelmed</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Irritated"></div>
              <div class="mood-label">Irritated</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Stress about work"></div>
              <div class="mood-label">Stressed about work</div>
            </div>
          </div>
        </div>
        <div>
          <div class="mood-cat">üòê Neutral / low-energy</div>
          <div class="mood-grid">
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Tired / fatigued"></div>
              <div class="mood-label">Tired / fatigued</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Bored"></div>
              <div class="mood-label">Bored</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Numb / indifferent"></div>
              <div class="mood-label">Numb / indifferent</div>
            </div>
          </div>
        </div>
        <div>
          <div class="mood-cat">üåû Positive</div>
          <div class="mood-grid">
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Happy"></div>
              <div class="mood-label">Happy</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Relaxed / calm"></div>
              <div class="mood-label">Relaxed / calm</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Excited / enthusiastic"></div>
              <div class="mood-label">Excited / enthusiastic</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Content / satisfied"></div>
              <div class="mood-label">Content / satisfied</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Proud"></div>
              <div class="mood-label">Proud</div>
            </div>
            <div class="mood-item">
              <div class="mood-checkbox"><input type="checkbox" name="mood" value="Focused"></div>
              <div class="mood-label">Focused</div>
            </div>
          </div>
        </div>
      </div>
      <div style="margin-top:8px;display:flex;align-items:center;gap:6px;">
        <label style="margin:0;">Other:</label>
        <input type="text" id="moodOtherText" placeholder="Enter other mood" style="width:auto;display:inline-block;" />
      </div>
      </fieldset>
    </details>


<fieldset class="where-ate" dir="ltr">
  <legend>Where did I eat?</legend>

  <div class="options">
    <label class="option">
      <input type="radio" name="locationChoice" value="Home">
      <span class="text">Home</span>
    </label>

    <label class="option">
      <input type="radio" name="locationChoice" value="At the desk">
      <span class="text">At the desk</span>
    </label>

    <label class="option">
      <input type="radio" name="locationChoice" value="In the kitchen at work">
      <span class="text">In the kitchen at work</span>
    </label>

    <label class="option">
      <input type="radio" name="locationChoice" value="Restaurant">
      <span class="text">Restaurant</span>
    </label>

    <label class="option">
      <input type="radio" name="locationChoice" value="Other">
      <span class="text">Other</span>
    </label>

    <!-- Row that shows the "Other" input aligned with the text column -->
    <div class="other-row" hidden>
      <span class="spacer" aria-hidden="true"></span>
      <input type="text" id="locationOther" placeholder="Enter other location">
    </div>
  </div>
</fieldset>

<style>
  /* Base container */
  .where-ate{
    margin-top:8px;
    border:1px solid #A678F0;
    padding:8px;
    border-radius:6px;
    text-align:left;       /* ensure left alignment in LTR */
  }

  /* Stack rows neatly */
  .options{
    display:grid;
    grid-auto-rows:auto;
    row-gap:8px;
  }

  /* Each option: radio column + text column */
  .option{
    display:grid;
    grid-template-columns: 1.25rem auto; /* fixed column for radio, flexible for text */
    column-gap:8px;
    align-items:start;                    /* radio aligns with first line of text */
    text-align:left;                      /* defend against global right-align */
    direction:ltr;                        /* defend against global RTL */
  }

  /* Normalize radio positioning */
  .option input[type="radio"]{
    place-self:start;     /* top-left of the grid cell */
    margin:0;             /* remove browser default margins */
    /* optional nudge if your browser centers the radio vertically:
       margin-top:0.15em; */
  }

  .option .text{
    line-height:1.3;      /* nicer wrapping on long labels */
    word-break:normal;    /* avoid forced word-by-word breaking */
  }

  /* "Other" row uses the same 2-column layout: spacer + input */
  .other-row{
    display:grid;
    grid-template-columns: 1.25rem auto;
    column-gap:8px;
    align-items:start;
  }

  .other-row .spacer{ width:1.25rem; }
  #locationOther{ min-width:200px; }
</style>


<script>
  // Show the "Other" text box only when "Other" is selected
  const otherInput = document.getElementById('locationOther');
  document.querySelectorAll('input[name="locationChoice"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      otherInput.style.display = e.target.value === 'Other' ? 'inline-block' : 'none';
    });
  });
</script>

    </fieldset>
    <label>Who was I with?</label>
      <input type="text" id="company" placeholder="e.g. alone, with friends, with family" />
      <div style="display:flex;align-items:center;gap:10px;"><span id="hungerBeforeVal" style="min-width:24px;text-align:center;background:#FFFFFF;padding:4px 8px;border-radius:6px;font-weight:600;color:#2D2D2D;border:1px solid #A678F0;">5</span><input type="range" id="hungerBefore" min="0" max="10" value="5" style="flex:1;max-width:200px;"></div>
    <label>How mindful was I while eating?</label>
      <div style="display:flex;align-items:center;gap:10px;"><span id="mindfulVal" style="min-width:24px;text-align:center;background:#FFFFFF;padding:4px 8px;border-radius:6px;font-weight:600;color:#2D2D2D;border:1px solid #A678F0;">5</span><input type="range" id="mindful" min="0" max="10" value="5" style="flex:1;max-width:200px;"></div>
    <label>How strong was the craving?</label>
      <div style="display:flex;align-items:center;gap:10px;"><span id="cravingVal" style="min-width:24px;text-align:center;background:#FFFFFF;padding:4px 8px;border-radius:6px;font-weight:600;color:#2D2D2D;border:1px solid #A678F0;">5</span><input type="range" id="craving" min="0" max="10" value="5" style="flex:1;max-width:200px;"></div>
    <label>How full did I feel after eating?</label>
      <div style="display:flex;align-items:center;gap:10px;"><span id="fullAfterVal" style="min-width:24px;text-align:center;background:#FFFFFF;padding:4px 8px;border-radius:6px;font-weight:600;color:#2D2D2D;border:1px solid #A678F0;">5</span><input type="range" id="fullAfter" min="0" max="10" value="5" style="flex:1;max-width:200px;"></div>
    <label>How did I feel after eating?</label>
      <input type="text" id="afterFeelingText" placeholder="e.g. guilty, satisfied, regretful, content" />
    <label>Do I have any physical symptoms?</label>
      <input type="text" id="symptomsText" placeholder="e.g. bloating, stomach pain, nausea, heartburn" />
    <label>Calories:</label>
      <input type="number" id="calories" placeholder="e.g. 500" />
    <label>Notes:</label>
      <textarea id="notes" placeholder="e.g. someone brought a birthday cake to the office"></textarea>
    <label>Photo:
      <input type="file" id="photo" accept="image/*" />
    </label>
    <div id="photoPreviewContainer" style="margin-top:8px;">
      <img id="photoPreview" src="" alt="Photo preview" style="max-width:120px;max-height:120px;display:none;border:1px solid #ddd;padding:4px;border-radius:4px;" />
    </div>
    <button type="submit" class="btn-add" aria-label="Add entry">üçΩÔ∏è Add Entry</button>
  </form>

  <div id="foodTable" class="food-groups">
    <!-- JS will render entries grouped by date here as <details> sections -->
  </div>

  <button class="btn-export" id="exportBtn">üìä Export to Excel</button>
  <!-- <button class="btn-export" id="syncBtn">‚òÅÔ∏è Sync from Cloud</button> -->

  <!-- Image modal / lightbox -->
  <div class="img-modal" id="imgModal" aria-hidden="true">
    <div class="img-modal-content" id="imgModalContent">
      <div class="controls">
        <button id="zoomInBtn" title="Zoom in">+</button>
        <button id="zoomOutBtn" title="Zoom out">‚àí</button>
        <button id="resetBtn" title="Reset">Reset</button>
        <button id="closeBtn" title="Close">‚úï</button>
      </div>
      <img id="modalImage" src="" alt="Food photo" />
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
  import { getFirestore, enableIndexedDbPersistence, collection, addDoc, getDocs, doc, setDoc, updateDoc, deleteDoc,
    onSnapshot, query, orderBy, serverTimestamp} from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';
  import { getAuth, signInAnonymously, onAuthStateChanged,
    setPersistence, browserLocalPersistence, inMemoryPersistence } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js';
  import { getAnalytics } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics.js';

 
  // Your web app's Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyAL75HN918LYXPNSB1sOg3IA-wC5mVJmmk",
    authDomain: "food-diary-private.firebaseapp.com",
    projectId: "food-diary-private",
    storageBucket: "food-diary-private.firebasestorage.app",
    messagingSenderId: "32004598058",
    appId: "1:32004598058:web:8d3398809951a4c4a5d653",
    measurementId: "G-RTL9YPVK2D"
  };

  // Initialize Firebase
  let db = null;
  let auth = null;
  let entries = [];
  let unsubscribeEntries = null;
  try {
    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);


    // ‚úÖ Multi-tab friendly persistence
    try {
      await enableIndexedDbPersistence(db, { synchronizeTabs: true });
    } catch (err) {
      console.warn('IndexedDB persistence error:', err);
    }

    auth = getAuth(app);
    getAnalytics(app);
    // Sign in anonymously
    signInAnonymously(auth).catch(error => {
      console.error("Anonymous auth failed: ", error);
      alert("Authentication failed. App will work with local storage only.");
    });
    // Wait for auth state

  onAuthStateChanged(auth, (user) => {
    if (!user) return;


      // If we already had a subscription, tear it down first
      if (typeof unsubscribeEntries === "function") {
        unsubscribeEntries();
        unsubscribeEntries = null;
      }

      // ‚úÖ Start the live subscription to Firestore
      unsubscribeEntries = startServerSync();
    });

  } catch (error) {
    console.error("Firebase init failed: ", error);
    alert("Firebase failed to initialize: " + error.message + ". App will work with local storage only.");
  }


  const form = document.getElementById('foodForm');
  const groupsContainer = document.getElementById('foodTable');
  const exportBtn = document.getElementById('exportBtn');
  const dateInput = document.getElementById('date');
  const timeInput = document.getElementById('time');
  const photoInput = document.getElementById('photo');

  // Modal elements
  const imgModal = document.getElementById('imgModal');
  const modalImage = document.getElementById('modalImage');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetBtn = document.getElementById('resetBtn');
  const closeBtn = document.getElementById('closeBtn');

  const now = new Date();
  dateInput.value = now.toLocaleDateString('en-CA');
  timeInput.value = now.toTimeString().slice(0,5);

  let editIndex = null;
  // photo being edited/previewed (data URL)
  let editingPhoto = null;

  // State for modal image transform
  let scale = 1;
  let translateX = 0;
  let translateY = 0;
  let isPanning = false;
  let startX = 0;
  let startY = 0;

  loadEntries();


  // --- Initial local load (keep for quick UI, but don't gate Firestore) ---
  async function loadEntries() {
    entries = JSON.parse(localStorage.getItem('foodEntries') || '[]');
    renderTable();
  }





  async function deleteEntryById(rawId) {
    try {
      // Ensure we pass a string path segment
      const id = typeof rawId === 'string' ? rawId : String(rawId);

      if (!id) {
        throw new Error('Missing document id');
      }
      if (id.includes('/')) {
        // Firestore doc IDs must not contain '/'
        throw new Error(`Invalid document id: "${id}"`);
      }

      console.log('Deleting Firestore doc id:', id, 'type:', typeof id);
      await deleteDoc(doc(db, 'foodEntries', id));
          console.log('Deleted entry', id);
      // UI will refresh automatically via onSnapshot
    } catch (err) {
      console.error('Delete failed:', err);
      alert('Delete failed: ' + (err?.message || err));
    }
  }


  // ‚úÖ Live sync from Firestore
  function startServerSync() {
    // If you want ordering, add orderBy('date', 'desc') etc.
    const q = query(collection(db, "foodEntries"/* your collection name */), /* orderBy('date','desc') */);

    return onSnapshot(q, (snap) => {
      const serverRows = snap.docs.map(d => ({ id: d.id, ...d.data() }));

      // Simple strategy: replace local array with server data
      entries = snap.docs.map(d => ({ id: d.id, ...d.data() })); // d.id is a string
      renderTable();

      // Keep localStorage in sync (optional)
      localStorage.setItem('foodEntries', JSON.stringify(entries));

      // Debug: see whether it‚Äôs cache or server
      console.log('fromCache?', snap.metadata.fromCache);
    }, (err) => {
      console.error('onSnapshot error:', err);
    });
  }


  // update displayed values for sliders
  ['hungerBefore','mindful','craving','fullAfter'].forEach(id => {
    const el = document.getElementById(id);
    const valEl = document.getElementById(id + 'Val');
    if (el && valEl) {
      el.addEventListener('input', () => valEl.textContent = el.value);
    }
  });

  // Photo input preview and editing state
  const photoPreview = document.getElementById('photoPreview');
  photoInput.addEventListener('change', function() {
    const f = photoInput.files[0];
    if (!f) {
      // user cleared file input; keep existing editingPhoto until save/clear
      return;
    }
    processImageFile(f).then(dataUrl => {
      editingPhoto = dataUrl;
      if (photoPreview) {
        photoPreview.src = dataUrl;
        photoPreview.style.display = 'inline-block';
      }
    }).catch(err => {
      console.error('Preview processing failed', err);
      alert('Could not process selected photo for preview.');
    });
  });

  // Location radio handlers: show/hide Other input
  const locationOther = document.getElementById('locationOther');
  function updateLocationOtherVisibility() {
    const sel = document.querySelector('input[name="locationChoice"]:checked');
    if (sel && sel.value === 'Other') {
      if (locationOther) {
        locationOther.style.display = 'inline-block';
        // focus the field so the user can type immediately
        setTimeout(() => { try { locationOther.focus(); } catch (e) {} }, 0);
      }
    } else {
      if (locationOther) { locationOther.style.display = 'none'; locationOther.value = ''; }
    }
  }
  document.querySelectorAll('input[name="locationChoice"]').forEach(r => r.addEventListener('change', updateLocationOtherVisibility));
  // initialize visibility on load
  updateLocationOtherVisibility();

  // Edit banner elements and handlers
  const editBanner = document.getElementById('editBanner');
  const cancelEditBtn = document.getElementById('cancelEditBtn');
  function showEditBanner() {
    if (editBanner) editBanner.style.display = 'block';
    // scroll to top so banner is visible
    try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch (e) { window.scrollTo(0,0); }
  }
  function hideEditBanner() {
    if (editBanner) editBanner.style.display = 'none';
  }
  if (cancelEditBtn) cancelEditBtn.addEventListener('click', function() {
    // cancel editing
    editIndex = null;
    editingPhoto = null;
    if (photoPreview) { photoPreview.src = ''; photoPreview.style.display = 'none'; }
    form.reset();
    dateInput.value = new Date().toLocaleDateString('en-CA');
    timeInput.value = new Date().toTimeString().slice(0,5);
    hideEditBanner();
  });

  // --- create per-mood sliders that appear when the checkbox is checked ---
  function sanitizeForId(s) { return String(s).replace(/[^a-z0-9]+/gi, '_'); }
  document.querySelectorAll('input[type="checkbox"][name="mood"]').forEach(cb => {
    const moodName = cb.value;
    const id = 'moodRange_' + sanitizeForId(moodName);
    const valId = 'moodRangeVal_' + sanitizeForId(moodName);
    if (document.getElementById(id)) return;
    const range = document.createElement('input');
    range.type = 'range'; range.min = 0; range.max = 10; range.value = 5; range.id = id;
    range.style.display = 'none'; range.style.width = '110px';
    const valSpan = document.createElement('span'); valSpan.id = valId; valSpan.textContent = range.value;
    valSpan.style.display = 'none'; valSpan.style.background = '#FFFFFF'; valSpan.style.color = '#2D2D2D'; valSpan.style.padding = '4px 8px'; valSpan.style.borderRadius = '6px'; valSpan.style.fontWeight = '600'; valSpan.style.border = '1px solid #A678F0';
    const item = cb.closest('.mood-item');
    if (item) {
      const label = item.querySelector('.mood-label');
      if (label) {
        label.after(range);
        range.after(valSpan);
      } else {
        item.appendChild(range);
        item.appendChild(valSpan);
      }
    } else {
      cb.parentNode.appendChild(range);
      cb.parentNode.appendChild(valSpan);
    }
    cb.addEventListener('change', () => {
      if (cb.checked) { range.style.display = 'inline-block'; valSpan.style.display = 'inline-block'; setTimeout(()=>{ try{ range.focus(); }catch(e){} },0); }
      else { range.style.display = 'none'; valSpan.style.display = 'none'; }
    });
    range.addEventListener('input', () => { valSpan.textContent = range.value; });
  });

  form.addEventListener('submit', function(e) {
    e.preventDefault();

    const file = photoInput.files[0];

    if (file) {
      // process image (resize/compress) to avoid localStorage quota issues on mobile
      processImageFile(file).then(dataUrl => {
        saveEntry(dataUrl);
      }).catch(err => {
        console.error('Image processing failed', err);
        alert('Could not process the photo. Try a smaller image or use a desktop to attach it.');
        // still try to save without photo
        saveEntry(null);
      });
    } else {
      // if editing an existing entry and no new file selected, keep the existing photo
      saveEntry(editingPhoto || null);
    }
  });

  // Read an image file and resize/compress it. Returns a Promise resolving to a data URL.
  function processImageFile(file, maxWidth = 1024, maxSizeBytes = 1024*700) {
    return new Promise((resolve, reject) => {
      try {
        const reader = new FileReader();
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            // compute new size keeping aspect ratio
            let iw = img.width;
            let ih = img.height;
            let scale = Math.min(1, maxWidth / Math.max(iw, ih));
            let sw = Math.round(iw * scale);
            let sh = Math.round(ih * scale);
            const canvas = document.createElement('canvas');
            canvas.width = sw;
            canvas.height = sh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, sw, sh);
            // try gradually reducing quality until size below threshold
            let quality = 0.9;
            function tryExport() {
              const dataUrl = canvas.toDataURL('image/jpeg', quality);
              // estimate size from base64 length
              const size = Math.round((dataUrl.length - 'data:image/jpeg;base64,'.length) * 3/4);
              if (size <= maxSizeBytes || quality <= 0.4) {
                resolve(dataUrl);
              } else {
                quality -= 0.15;
                tryExport();
              }
            }
            tryExport();
          };
          img.onerror = () => reject(new Error('Invalid image'));
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      } catch (err) {
        reject(err);
      }
    });
  }

  // collect mood intensities for checked moods (returns object { moodName: value })
  function getMoodIntensities() {
    const out = {};
    document.querySelectorAll('input[type="checkbox"][name="mood"]').forEach(cb => {
      if (cb.checked) {
        const id = 'moodRange_' + String(cb.value).replace(/[^a-z0-9]+/gi, '_');
        const r = document.getElementById(id);
        if (r) out[cb.value] = Number(r.value);
        else out[cb.value] = 5;
      }
    });
    return out;
  }

  function saveEntry(photoData) {
    // determine location value from radios / other text
    let locationVal = '';
    const locSel = document.querySelector('input[name="locationChoice"]:checked');
    if (locSel) {
      if (locSel.value === 'Other') {
        locationVal = (document.getElementById('locationOther') || { value: '' }).value.trim();
      } else {
        locationVal = locSel.value;
      }
    } else {
      // fallback: empty or previous manual value
      locationVal = (document.getElementById('locationOther') || { value: '' }).value.trim();
    }

    const entry = {
      id: editIndex === null ? Date.now() : entries[editIndex].id,
      date: dateInput.value,
      time: timeInput.value,
      mood: getSelectedMoods(),
      moodIntensities: getMoodIntensities(),
      location: locationVal,
      company: document.getElementById('company').value,
      hungerBefore: document.getElementById('hungerBefore').value,
      mindful: document.getElementById('mindful').value,
      craving: document.getElementById('craving').value,
      fullAfter: document.getElementById('fullAfter').value,
      afterFeeling: document.getElementById('afterFeelingText').value,
      symptoms: document.getElementById('symptomsText').value,
      calories: document.getElementById('calories').value,
      notes: document.getElementById('notes').value,
      photo: photoData
    };

    if (editIndex === null) {
      // Add new entry to localStorage and Firebase
      entries.push(entry);
      localStorage.setItem('foodEntries', JSON.stringify(entries));
      if (db) {
        addDoc(collection(db, "foodEntries"), entry).then(docRef => {
          entry.id = docRef.id;
          // Update localStorage with the id
          localStorage.setItem('foodEntries', JSON.stringify(entries));
        }).catch(error => {
          console.error("Error adding to Firebase: ", error);
        });
      }
    } else {
      // Update existing entry in localStorage and Firebase
      entries[editIndex] = entry;
      editIndex = null;
      localStorage.setItem('foodEntries', JSON.stringify(entries));
      if (db) {
        updateDoc(doc(db, "foodEntries", entry.id), entry).catch(error => {
          console.error("Error updating in Firebase: ", error);
        });
      }
    }
    renderTable();

    form.reset();
    dateInput.value = new Date().toLocaleDateString('en-CA');
    timeInput.value = new Date().toTimeString().slice(0,5);
    // clear editing state and preview
    editingPhoto = null;
    const photoPreview = document.getElementById('photoPreview');
    if (photoPreview) { photoPreview.src = ''; photoPreview.style.display = 'none'; }
    // clear location radios and other field
    document.querySelectorAll('input[name="locationChoice"]').forEach(r => r.checked = false);
    const locationOtherEl = document.getElementById('locationOther');
    if (locationOtherEl) { locationOtherEl.value = ''; locationOtherEl.style.display = 'none'; }
    // hide any displayed mood ranges and clear other mood text
    document.querySelectorAll('[id^="moodRange_"]').forEach(r => { r.style.display = 'none'; });
    document.querySelectorAll('[id^="moodRangeVal_"]').forEach(s => { s.style.display = 'none'; });
    const moodOther = document.getElementById('moodOtherText'); if (moodOther) moodOther.value = '';
    // hide edit banner if present
    try { hideEditBanner(); } catch (e) {}
  }

  function renderTable() {
    // Render entries grouped by date into the groupsContainer using <details> sections.
    groupsContainer.innerHTML = '';
    if (!entries || entries.length === 0) {
      groupsContainer.innerHTML = '<p style="color:#666">No entries yet.</p>';
      return;
    }

    // Group entries by date
    const groups = {};
    entries.forEach((entry, idx) => {
      const d = entry.date || 'No date';
      if (!groups[d]) groups[d] = [];
      groups[d].push({ entry, idx });
    });

    // Sort dates descending (newest first)
    const dates = Object.keys(groups).sort((a,b) => b.localeCompare(a));

    dates.forEach(date => {
      const items = groups[date];
      const details = document.createElement('details');
      details.style.marginBottom = '15px';
      const summary = document.createElement('summary');
      summary.textContent = `${date} (${items.length} entries)`;
      summary.style.cursor = 'pointer';
      details.appendChild(summary);

      const container = document.createElement('div');
      container.style.marginTop = '10px';

      items.forEach(({ entry, idx }) => {
        const card = document.createElement('div');
        card.style.cssText = 'background:#fff; border:1px solid #ddd; border-radius:6px; padding:12px; margin-bottom:10px; box-shadow:0 2px 4px rgba(0,0,0,0.1);';
        
        let moodDisplay = '';
        if (entry && entry.moodIntensities && Object.keys(entry.moodIntensities).length) {
          moodDisplay = Object.entries(entry.moodIntensities).map(([k,v]) => `${k} (${v})`).join(', ');
        } else if (Array.isArray(entry.mood)) {
          moodDisplay = entry.mood.join(', ');
        } else {
          moodDisplay = entry.mood || '';
        }

        const fields = [
          { label: 'Time', value: entry.time || '' },
          { label: 'Mood before eating', value: moodDisplay },
          { label: 'Location', value: entry.location || '' },
          { label: 'Company', value: entry.company || '' },
          { label: 'Hunger Before', value: entry.hungerBefore || '' },
          { label: 'Mindful', value: entry.mindful || '' },
          { label: 'Craving', value: entry.craving || '' },
          { label: 'Full After', value: entry.fullAfter || '' },
          { label: 'After Feeling', value: entry.afterFeeling || '' },
          { label: 'Symptoms', value: entry.symptoms || '' },
          { label: 'Calories', value: entry.calories || '' },
          { label: 'Notes', value: entry.notes || '' }
        ];

        // card header with icon (time moved to the 'Time' field)
        let cardHTML = `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
            <div style="font-weight:600;">üçΩÔ∏è Meal</div>
          </div>`;
        fields.forEach(field => {
          if (field.value) {
            cardHTML += `<div style="display:flex; justify-content:space-between; margin-bottom:6px;"><strong>${field.label}:</strong> <span>${field.value}</span></div>`;
          }
        });

        if (entry.photo) {
          cardHTML += `<div style="margin-top:8px;"><img src="${entry.photo}" class="photo-thumb" data-index="${idx}" style="margin-top:4px;" /></div>`;
        }

       
        cardHTML += `<div style="margin-top:8px; display:flex; gap:6px;">
            <button data-action="edit" data-index="${idx}">Edit</button>
            <button data-action="delete" data-index="${idx}" ${entry.id ? `data-id="${entry.id}"` : ''}>Delete</button>
          </div>`;


        card.innerHTML = cardHTML;
        container.appendChild(card);
      });

      details.appendChild(container);
      groupsContainer.appendChild(details);
    });


    // Ensure thumbnails are keyboard-focusable and rely on the delegated handlers
    groupsContainer.querySelectorAll('.photo-thumb').forEach(img => {
      img.style.pointerEvents = 'auto';
      img.tabIndex = 0;
    });
  }


      // Delegate edit/delete via buttons (use event delegation for robustness)    
  // Attach once (outside renderTable; or at the end of renderTable if you prefer)
    groupsContainer.addEventListener('click', (e) => {
      const delBtn = e.target.closest('button[data-action="delete"]');
      if (delBtn) {
        const entryId = delBtn.dataset.id; // <- use a data-id on the button, not index

        if (!entryId) return;

        // Find entry in array by id
        const entryIndex = entries.findIndex(e => e.id === entryId);
        if (entryIndex === -1) return;

        const entry = entries[entryIndex];

        // Remove from Firestore first
        if (entry.id) {
          deleteDoc(doc(db, "foodEntries", entry.id))
            .then(() => {
              // Remove locally only after Firestore confirms
              entries.splice(entryIndex, 1);
              localStorage.setItem('foodEntries', JSON.stringify(entries));
              renderTable();
            })
            .catch(console.error);
        } else {
          // If no id (local only), just remove
          entries.splice(entryIndex, 1);
          localStorage.setItem('foodEntries', JSON.stringify(entries));
          renderTable();
        }

        return;
      }

      // Handle Edit
      const editBtn = e.target.closest('button[data-action="edit"]');
      if (editBtn) {
        const idx = Number(editBtn.dataset.index);
        if (Number.isNaN(idx)) {
          console.warn('Edit clicked with invalid index:', editBtn.dataset.index);
          return;
        }
        window.editEntry(idx);
      }
    });



  // Delegated handlers: robust fallback if individual listeners fail for any reason
  groupsContainer.addEventListener('click', function(e) {
    const img = e.target.closest('.photo-thumb');
    if (!img) return;
    const idx = img.dataset.index;
    if (idx == null) return;
    openImageModal(Number(idx));
  });
  groupsContainer.addEventListener('keydown', function(e) {
    const img = e.target.closest('.photo-thumb');
    if (!img) return;
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      const idx = img.dataset.index;
      if (idx == null) return;
      openImageModal(Number(idx));
    }
  });

  // Expose edit/delete to global scope (used by inline onclicks)
  window.editEntry = function(index) {
    const entry = entries[index];
    dateInput.value = entry.date;
    timeInput.value = entry.time;
    populateMoodControls(entry.mood, entry.moodIntensities || {});
  // populate location radios / Other
  const loc = entry.location || '';
  if (loc) {
    const match = Array.from(document.querySelectorAll('input[name="locationChoice"]')).find(r => r.value === loc);
    if (match) {
      match.checked = true;
      if (locationOther) locationOther.style.display = 'none';
    } else {
      const otherRadio = document.querySelector('input[name="locationChoice"][value="Other"]');
      if (otherRadio) otherRadio.checked = true;
      if (locationOther) { locationOther.style.display = 'inline-block'; locationOther.value = loc; }
    }
  } else {
    document.querySelectorAll('input[name="locationChoice"]').forEach(r => r.checked = false);
    if (locationOther) { locationOther.value = ''; locationOther.style.display = 'none'; }
  }
  document.getElementById('company').value = entry.company || '';
    document.getElementById('hungerBefore').value = entry.hungerBefore || 5;
    document.getElementById('mindful').value = entry.mindful || 5;
    document.getElementById('craving').value = entry.craving || 5;
    document.getElementById('fullAfter').value = entry.fullAfter || 5;
    document.getElementById('afterFeelingText').value = entry.afterFeeling || '';
    document.getElementById('symptomsText').value = entry.symptoms || '';
    // update slider labels
    document.getElementById('hungerBeforeVal').textContent = document.getElementById('hungerBefore').value;
    document.getElementById('mindfulVal').textContent = document.getElementById('mindful').value;
    document.getElementById('cravingVal').textContent = document.getElementById('craving').value;
    document.getElementById('fullAfterVal').textContent = document.getElementById('fullAfter').value;
    document.getElementById('calories').value = entry.calories;
    document.getElementById('notes').value = entry.notes;
    editIndex = index;
    // set editing photo preview (preserve existing photo until replaced)
    editingPhoto = entry.photo || null;
    if (editingPhoto && photoPreview) {
      photoPreview.src = editingPhoto;
      photoPreview.style.display = 'inline-block';
    } else if (photoPreview) {
      photoPreview.src = '';
      photoPreview.style.display = 'none';
    }
    // clear any selected file in the input so we don't accidentally read a stale FileList
    if (photoInput) photoInput.value = '';
    // show edit banner and scroll to top
    try { showEditBanner(); } catch (e) {}
  };

  window.deleteEntry = function(index) {
    if (confirm("Are you sure you want to delete this entry?")) {
      const entryId = entries[index].id;
      entries.splice(index, 1);
      localStorage.setItem('foodEntries', JSON.stringify(entries));
      if (db) {
        deleteDoc(doc(db, "foodEntries", entryId)).catch(error => {
          console.error("Error deleting from Firebase: ", error);
        });
      }
      renderTable();
    }
  };

  exportBtn.addEventListener('click', function() {
    const exportEntries = entries.map(entry => {
      const e = { ...entry };
      if (e.photo) e.photo = '[Image]';
      return e;
    });
    const worksheet = XLSX.utils.json_to_sheet(exportEntries);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Food Diary');
    XLSX.writeFile(workbook, 'food-diary.xlsx');
  });

  // Mood helpers
  function getSelectedMoods() {
    const checked = Array.from(document.querySelectorAll('input[type=checkbox][name="mood"]:checked'))
      .map(cb => cb.value);
    const otherText = document.getElementById('moodOtherText').value.trim();
    if (otherText) checked.push(otherText);
    return checked;
  }

  function populateMoodControls(moodValue, moodInts = {}) {
    // Clear all
    document.querySelectorAll('input[type=checkbox][name="mood"]').forEach(cb => cb.checked = false);
    document.getElementById('moodOtherText').value = '';

    // hide all mood ranges initially
    document.querySelectorAll('[id^="moodRange_"]').forEach(r => { r.style.display = 'none'; });
    document.querySelectorAll('[id^="moodRangeVal_"]').forEach(s => { s.style.display = 'none'; });

    if (!moodValue) return;
    const moods = Array.isArray(moodValue) ? moodValue : [moodValue];
    moods.forEach(m => {
      // try to find exact match among checkboxes
      const match = Array.from(document.querySelectorAll('input[type=checkbox][name="mood"]'))
        .find(cb => cb.value === m);
      if (match) {
        match.checked = true;
        // show and set the corresponding range if present
        const rid = 'moodRange_' + String(m).replace(/[^a-z0-9]+/gi, '_');
        const vid = 'moodRangeVal_' + String(m).replace(/[^a-z0-9]+/gi, '_');
        const r = document.getElementById(rid);
        const v = document.getElementById(vid);
        if (r) {
          r.style.display = 'inline-block';
          if (moodInts && moodInts[m] != null) r.value = moodInts[m];
        }
        if (v) { v.style.display = 'inline-block'; v.textContent = (moodInts && moodInts[m] != null) ? moodInts[m] : (r ? r.value : '5'); }
      } else {
        // fill other text
        const otherText = document.getElementById('moodOtherText');
        otherText.value = m;
      }
    });
  }


  // ----- Modal functions -----
  function openImageModal(index) {
    const entry = entries[index];
    if (!entry || !entry.photo) return;
    console.debug('openImageModal called for index', index);
    modalImage.src = entry.photo;
    resetTransform();
    imgModal.classList.add('open');
    imgModal.setAttribute('aria-hidden', 'false');
    modalImage.style.cursor = 'grab';
    // Focus to capture keyboard events
    document.addEventListener('keydown', onKeyDown);
  }
  window.openImageModal = openImageModal; // allow inline call

  function closeImageModal() {
    imgModal.classList.remove('open');
    imgModal.setAttribute('aria-hidden', 'true');
    document.removeEventListener('keydown', onKeyDown);
  }

  function resetTransform() {
    scale = 1;
    translateX = 0;
    translateY = 0;
    applyTransform();
  }

  function applyTransform() {
    modalImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  }

  function changeScale(delta, centerX, centerY) {
    console.debug('changeScale', { delta, scaleBefore: scale, centerX, centerY });
    const prevScale = scale;
    scale = Math.max(0.5, Math.min(5, scale + delta));
    // Adjust translate to zoom toward pointer
    if (centerX != null && centerY != null) {
      const rect = modalImage.getBoundingClientRect();
      const dx = centerX - rect.left;
      const dy = centerY - rect.top;
      // compute new translation so that point under cursor stays roughly fixed
      translateX -= (dx / prevScale) * (scale - prevScale);
      translateY -= (dy / prevScale) * (scale - prevScale);
    }
    // only apply transform if modalImage is in the DOM and has naturalWidth (loaded)
    if (modalImage && modalImage.complete && modalImage.naturalWidth) {
      applyTransform();
    } else {
      console.warn('applyTransform skipped: image not loaded/available');
    }
  }

  // Mouse wheel to zoom
  imgModal.addEventListener('wheel', function(e) {
    if (!imgModal.classList.contains('open')) return;
    console.debug('imgModal wheel event', { deltaY: e.deltaY });
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    changeScale(delta, e.clientX, e.clientY);
  }, { passive: false });

  // Buttons
  if (zoomInBtn) zoomInBtn.addEventListener('click', () => changeScale(0.2)); else console.warn('zoomInBtn missing');
  if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => changeScale(-0.2)); else console.warn('zoomOutBtn missing');
  resetBtn.addEventListener('click', resetTransform);
  closeBtn.addEventListener('click', closeImageModal);

  // Drag to pan
  modalImage.addEventListener('mousedown', function(e) {
    if (!imgModal.classList.contains('open')) return;
    isPanning = true;
    startX = e.clientX - translateX;
    startY = e.clientY - translateY;
    modalImage.style.cursor = 'grabbing';
    e.preventDefault();
  });
  window.addEventListener('mousemove', function(e) {
    if (!isPanning) return;
    translateX = e.clientX - startX;
    translateY = e.clientY - startY;
    applyTransform();
  });
  window.addEventListener('mouseup', function() {
    if (isPanning) {
      isPanning = false;
      modalImage.style.cursor = 'grab';
    }
  });
  
  // Optional: clean up when leaving the page
  window.addEventListener('beforeunload', () => {
    if (typeof unsubscribeEntries === "function") unsubscribeEntries();
   });


  // Touch events for mobile
  modalImage.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) {
      const t = e.touches[0];
      isPanning = true;
      startX = t.clientX - translateX;
      startY = t.clientY - translateY;
    }
  }, { passive: true });
  modalImage.addEventListener('touchmove', function(e) {
    if (!isPanning || e.touches.length !== 1) return;
    const t = e.touches[0];
    translateX = t.clientX - startX;
    translateY = t.clientY - startY;
    applyTransform();
  }, { passive: true });
  modalImage.addEventListener('touchend', function() { isPanning = false; });

  // Close modal when clicking backdrop
  imgModal.addEventListener('click', function(e) {
    if (e.target === imgModal) closeImageModal();
  });

  function onKeyDown(e) {
    if (e.key === 'Escape') closeImageModal();
    if (e.key === '+') changeScale(0.2);
    if (e.key === '-') changeScale(-0.2);
    if (e.key === '0') resetTransform();
  }
</script>

</body>
</html>
